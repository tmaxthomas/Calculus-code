package tmaxthomas.lib;

public class CalculusMachine
{
	//This function serves as an initialization point for the recursive evaluation-it generates the tree and starts the recursive evaluator
	public static double evaluate(String input, double index)
	{
		double output = 1;
		String tempstring = input;
		tempstring = format(tempstring);
		CalcTree parsetree = CalcTree.generateTree(tempstring);
		output = recurseEvaluate(parsetree, index);
		return output;
	}
	//This function recursively evaluates the parse tree generated by the evaluate function
	public static double recurseEvaluate(CalcTree tree, double index)
	{
		double result = 0;
		//If the branch is a number, and therefore a leaf, return the stored number
		if(tree.operator == CalcTree.Operators.NULL)
		{
			if(!isANumber(tree.val.charAt(0)))
			{
				return index;	
			}
			else if(tree.val.length() > 1 && !isANumber(tree.val.charAt(1)))
			{
				return -index;
			}
			else
			{
				return Double.valueOf(tree.val);
			}
		}
		//Else, figure out what sort of operator it is, and recursively evaluate the connecting branches.
		else
		{
			if(tree.operator == CalcTree.Operators.ADD)               return recurseEvaluate(tree.leftbranch, index) + recurseEvaluate(tree.rightbranch, index);
			if(tree.operator == CalcTree.Operators.SUBTRACT)          return recurseEvaluate(tree.leftbranch, index) - recurseEvaluate(tree.rightbranch, index);
			if(tree.operator == CalcTree.Operators.MULTIPLY)          return recurseEvaluate(tree.leftbranch, index) * recurseEvaluate(tree.rightbranch, index);
			if(tree.operator == CalcTree.Operators.DIVIDE)            return recurseEvaluate(tree.leftbranch, index) / recurseEvaluate(tree.rightbranch, index);
			if(tree.operator == CalcTree.Operators.EXPONENTIATE)      return Math.pow(recurseEvaluate(tree.leftbranch, index), recurseEvaluate(tree.rightbranch, index));
			if(tree.operator == CalcTree.Operators.NATURAL_LOGARITHM) return Math.log(recurseEvaluate(tree.leftbranch, index));
			if(tree.operator == CalcTree.Operators.SINE)              return Math.sin(recurseEvaluate(tree.leftbranch, index));
			if(tree.operator == CalcTree.Operators.COSINE)            return Math.cos(recurseEvaluate(tree.leftbranch, index));
			if(tree.operator == CalcTree.Operators.TANGENT)           return Math.tan(recurseEvaluate(tree.leftbranch, index));
		}
		return result;
	}
	//This function performs initial formatting on input strings
	static String format(String input)
	{
		//It removes spaces
		String output = input;
		for(int a = 0; a < output.length(); a++)
		{
			if(output.charAt(a) == ' ')
			{
				output = shunt(1, a, output, ' ');
			}
		}
		//And makes implicit multiplication explicit
		for(int a = 1; a < output.length(); a++)
		{
			if(output.charAt(a) == 'x' || output.charAt(a) == '(')
			{
				if((isANumber(output.charAt(a - 1)) || output.charAt(a - 1) == 'x') || (output.charAt(a) == '(' && output.charAt(a - 1) == ')'))
				{
					output = shunt(0, a, output, '*');
					a++;
				}
			}
		}
		output = output.replaceAll("e", Double.toString(Math.E));
		output = output.replaceAll("pi", Double.toString(Math.PI));
		//This for loop deals with negative signs
		for(int a = 0; a < output.length(); a++)
		{
			if(a == 0 && output.charAt(a) == '-')
			{
				a++;
				output = "0" + output;
			}
			else if(output.charAt(a) == '-' && (!isANumber(output.charAt(a-1)) && output.charAt(a - 1) != 'x'))
			{
				output = shunt(0, a, output, '0');
				a++;
			}
		}
		return output;
	}
	/*This function serves two functions-if the direction is 0, it inserts a character into a string at an inputted index
	 * If the direction is 1, it instead removes whatever character is at the given index.
	 */
	static String shunt(int direction, int index, String input, char insertchar)
	{
		String output = "";
		if(direction == 0)
		{
			String temp1, temp2 = Character.toString(insertchar), temp3;
			temp1 = input.substring(0, index);
			temp3 = input.substring(index);
			output = output.concat(temp1.concat(temp2.concat(temp3)));
		}
		
		else
		{
			String temp1, temp2;
			temp1 = input.substring(0, index);
			temp2 = input.substring(index + 1);
			output = output.concat(temp1.concat(temp2));
		}
		
		return output;
	}
	//This method sees whether a given character represents a number via the ASCII values of numerals and the period.
	static boolean isANumber(char input)
	{
		boolean result;
		if((input < 48 || input > 57) && input != 46 && input != 45)
		{
			result = false;
		}
		else
		{
			result = true;
		}
		return result;
	}
}
